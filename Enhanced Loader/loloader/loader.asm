;*********************************;;         LOADER64;      LOAD.C64 V072882;LOAD OBJECT FILE FROM ASSEMBLER64; (C) 1982 BY COMMODORE MACHINES;;  DOCUMENTED BY DENTON MARLOWE;*********************************; ZEROPAGE USAGE EQUATES;*********************************STATUS=$90    ;STATUS BYTEZEROPG=$FB    ;ZERO PAGE POINTERZEROUR=$FD    ;ZERO PAGE POINTER;*********************************; RETURN TO BASIC EQUATE; VECTOR IS AT $A002;*********************************;WINIT  =$E391  ;BASIC WARM STARTBASWST  =$E391  ;BASIC WARM START;BASWST  =$E37B  ;BASIC WARM START;*********************************; KERNAL JMUP TABLE EQUATES;*********************************STOP  =$FFE1  ;CHECK FOR STOPSETLFS=$FFBA  ;SET LOGICAL FILESETNAM=$FFBD  ;SET FILENAMEOPEN  =$FFC0  ;OPEN FILECLOSE =$FFC3  ;CLOSE LOGICAL FILECHKIN =$FFC6  ;OPEN INPUT CHANNELCLRCHN=$FFCC  ;RESET I/O CHANNELSCHRIN =$FFCF  ;GET KEYBOARD INPUTCHROUT=$FFD2  ;OUTPUT CHARACTER;LOAD  =$FFD5SAVE  =$FFD8GETIN =$FFE4READST=$FFB7MEMSIZ=$37   ;TOP OF FREE RAM+1;*********************************;; LOADER64 ENTRY POINT;;*********************************LOADER JSR CLRCHN  ;RSET I/O LDA #$00        ;ZERO BYTE STA RECORD      ;RECORD COUNT STA RECORD+1    ; STA OFFSET      ;LOAD OFFSET STA OFFSET+1    ; STA STATUS      ;I/O STATUS;*********************************; PRINT TITLE;********************************* LDX #MSG7-MSG1  ;OFFSET FOR TITLE JSR PRINT       ;PRINT TITLE BCC LOADER      ;IF ERROR RESET;*********************************; CLEAR ERROR FLAG;********************************* LDA #$00        ;ERROR CODE STA ECODE       ;SET ERROR  STA SAFG        ;CLEAR START ADDRESS FLAG;*********************************; INPUT FILE NAME;********************************* LDX #MSG8-MSG1  ;FILE NAME JSR PRINT       ;PRINT IT LDX #$28        ;CHAR COUNT STX COUNT       ;STORE IN COUNTSPACE DEC COUNT  ;DEC COUNT BEQ LOADER      ;IF ZERO RESET JSR CHRIN       ;GET CHAR CMP #' '        ;IS IT A SPACE BEQ SPACE       ;IF SO LOOP CMP #$0D        ;IS FIRST CR? BNE NAME        ;IF NOT BRANCH LDA #'E'        ;ERROR CODE STA ECODE       ;SET ERROR JMP QUIT        ;QUIT LOADER;*********************************; INPUT AND PARSES FILENAME;*********************************NAME LDX #$00    ;ZERO BYTE STX COUNT1      ;CHAR COUNT BEQ CRLFD        ;BRANCH ALWAYSGETC  JSR CHRIN  ;GET NEXT CHAR CMP #' '        ;IS IT A SPACE? BEQ DNAME       ;NONE ALLOWEDCRLFD CMP #$0D    ;IS IT CR? BEQ DNAME       ;END OF NAME LDX COUNT1      ;GET CHAR COUNT CPX #$0F        ;15 CHARS? BEQ LOADER      ;RESTART LOADER STA BUF,X       ;STORE CHAR INX             ;INC OFFSET STX COUNT1      ;CHAR COUNT JMP GETC        ;GET NEXT CHAR;*********************************; ADD DISK SEQ FILENAME;*********************************DNAME LDA #',' ;ASCII "," STA BUF,X     ;PUT IN BUFFER INX           ;INC OFFSET LDA #'S'      ;FOR SEQ FILE STA BUF,X     ;PUT IN BUFFER INX           ;INC OFFSET STX COUNT1    ;SAVE NUMBER CHARS;*********************************; OUTPUT CARRAIGE RETURN;********************************* LDA #$0D      ;ASCII CR JSR CHROUT    ;PRINT IT;*********************************; COMMAND CHANNEL INITIALIZE DRIVE;********************************* LDA #$07    ;FILE #7 LDX #$08    ;DEVICE #8 LDY #$0F    ;SEC ADR #15 JSR SETLFS  ;SET FILE PARA; LDX #<INIT  ;LOW FILENAME LDY #>INIT  ;HIGH FILENAME LDA #$02    ;LENGTH OF NAME JSR SETNAM  ;SET FILENAME JSR OPEN    ;OPEN FILE; LDA STATUS  ;GET STATUS BEQ OK      ;ZERO IF OK CMP #$40    ;IS IT 64? BNE ERROR1  ;ERROR;OK LDA #$07  ;FILE #7 JSR CLOSE   ;CLOSE FILE;*********************************; OPEN OBJECT FILE;********************************* LDA #$07    ;FILE #7 LDX #$08    ;DEVICE #8 LDY #$07    ;SECOND ADDRESS JSR SETLFS  ;SET FILE; LDX #<BUF   ;LOW FILENAME LDY #>BUF   ;HIGH FILENAME LDA COUNT1  ;GET LENGTH JSR SETNAM  ;SET FILENAME; JSR OPEN        ;OPEN FILE LDA STATUS      ;CHECK STATUS BEQ OK3         ;IF ZERO OK CMP #$40        ;END OF FILE? BEQ OK3         ;IF SO OKERROR1 JMP ERROR ;FILE ERROR;OK3 LDX #$07     ;FILE #7 JSR CHKIN       ;INPUT FILE;*********************************; CHECK STOP KEY FOR BREAK;*********************************CKSTOP JSR STOP  ;CHECK STOP BNE OK2         ;IF NOT GO ON. JMP BREAK       ;BREAK ERROR;*********************************; INPUT CODE IN CBM OBJECT FORMAT;*********************************OK2  JSR INPUT   ;GET BYTE CMP #';'        ;START OF RECORD BNE CKSTOP      ;IF NOT TRY AGAIN; LDA #$00        ;ZERO BYTE STA USER        ;ZERO CHECK LOW STA USER+1      ;ZERO CHECK HIGH STA COUNT       ;ZERO BYTE COUNT; JSR GETBYT      ;GET BYTE BNE RECGOD      ;<>0 NOT LAST JSR GETBYT      ;GET RECORD COUNT CMP RECORD+1    ;SAME AS REC HIGH BEQ NEXCT       ;IF EQUAL NEXT JMP RECERR      ;BAD REC COUNT;NEXCT JSR GETBYT ;GET RECORD COUNT CMP RECORD      ;SAME AS REC LOW BNE RECER      ;BAD REC COUNT JMP QUIT        ;ALL LOADED;*********************************; INPUT RECORD;*********************************RECER JMP RECERR ;;*********************************; INPUT RECORD;*********************************RECGOD STA NUMBYT ;STORE NUM BYTES INC RECORD       ;INC REC COUNT BNE SKPIN1       ;ZERO? INC RECORD+1     ;IF SO INC HIGHSKPIN1 JSR SUMBYT ;SUM BYTES; JSR GETBYT       ;GET HIH ADDRESS; PHA              ;SAVE; CLC              ;CLEAR CARRY; ADC OFFSET+1     ;ADD OFFSET STA ZEROPG+1     ;STORE IN POINT; PLA              ;PULL ADDRESS JSR SUMBYT       ;SUM BYTES; JSR GETBYT       ;GET LOW ADDRESS; PHA              ;STORE; CLC              ;CLEAR CARRY; ADC OFFSET       ;ADD OFFSET STA ZEROPG       ;STORE IN POINT; BCC SKPINC       ;IF C=0 SKIP; INC ZEROPG+1     ;INC HIH ADDRESSSKPINC =* ;PLA        ;PULL ADDRRESS JSR SUMBYT       ;SUM BYTES; LDA RECORD       ;GET REC COUNT CMP #$01         ;FIRST ONE BNE MORBYT       ;IF NOT GO ON; LDA #$0D         ;ASCII CR JSR CHROUT       ;PRINT IT;*********************************; PRINT LOAD ADDRESS;********************************* JSR PRTADD       ;PRINT ADDRESS;*********************************; READ IN ASCII BYTE DATA; ANOTHER FLAG IN NEEDED FOR RECORD COUNT; IF THERE ARE MORE THAN 255 RECORDS; THE COUNT WILL ROLL OVER AND PRINT; CURRENT RECORED LOAD ADDRESS;********************************* LDA SAFG     ;CHECK START ADDRESS FLAG BNE MORBYT   ;IF SET SKIP NEXT LDA #$01 STA SAFG LDA SAV STA SA LDA SAV+1 STA SA+1;*********************************; READ IN ASCII BYTE DATA;*********************************MORBYT JSR GETBYT ;GET DATA BYTE LDY COUNT        ;GET BYTE COUNT STY COUNT1       ;SAVE COUNT INC COUNT        ;INC COUNT; STA (ZEROPG),Y   ;STORE DATA CMP (ZEROPG),Y   ;CHECK DATA BNE NONRAM       ;IF <> ERROR JSR SUMBYT       ;SUM BYTES; DEC NUMBYT       ;DEC BYTE COUNT BNE MORBYT       ;IF <>0 MORE;*********************************; CHECK RECORD CHECKSUM;********************************* JSR GETBYT       ;GET HIH CHECK CMP USER+1       ;COMPARE, SAME? BNE CHKERR       ;IF NOT ERROR JSR GETBYT       ;GET LOW CHECK CMP USER         ;COMPARE, SAME? BNE CHKERR       ;IF NOT ERROR LDA #'.'         ;ASCII PERIOD JSR CHROUT       ;PRINT IT JMP CKSTOP       ;NEXT RECORD;*********************************; ERROR MESSAGE POINTERS;*********************************ERROR =* LDA #'E' STA ECODE LDX #MSG6-MSG1  ;FILE ERROR;.BYTE $2CNONRAM LDX #MSG4-MSG1 ;NON-RAM LOAD;.BYTE $2CCHKERR LDX #MSG5-MSG1 ;CHECKSUM ERROR;.BYTE $2CBREAK LDX #MSG2-MSG1 ;BREAK ERROR;.BYTE $2CRECERR LDX #$00 ;BAD RECORD COUNT;*********************************; CLOSE OUT FILE AND RESET I/O;********************************* JSR PRINT      ;PRINT MESSAGEQUIT JSR CLRCHN ;RESET I/O LDA #$07       ;FILE #7 JSR CLOSE      ;CLOSE LDA ECODE CMP #'E' BNE PADR ;JMP BASWST       ;BACK TO BASIC RTS           ;BACK TO BASIC;*********************************; PRINT END OF LOAD ADDRESS;*********************************PADR =* CLC            ;CLEAR CARRY LDA COUNT1     ;GET LAST OFFSET ADC ZEROPG     ;ADD TO LAST REC STA ZEROPG     ;LOAD ADDRESS LDA ZEROPG+1   ; ADC #$00       ; STA ZEROPG+1   ;; LDA #$0D       ;ASCII CR JSR CHROUT     ;PRINT IT; JSR PRTADD     ;PRINT ADDRESS;*********************************;;********************************* LDA SAV STA EA LDA SAV+1 STA EA+1;*********************************;;********************************* LDX #MSG3-MSG1 ;END OF LOAD JSR PRINT      ;PRINT IT;*********************************;;********************************* JSR SAVOBJ;*********************************;;********************************* ;JMP BASWST       ;BACK TO BASIC RTS       ;BACK TO BASIC;*********************************; OUTPUT STRING ROUTINE;*********************************PRINT STX COUNT ;PUT X IN COUNTPLOOP LDX COUNT ;LOAD X FROM COUNT LDA MSG1,X     ;LOAD CHAR PHP            ;SAVE STATUS FLAG AND #$7F       ;MASK BIT 8 JSR CHROUT     ;PRINT CHAR INC COUNT      ;INC OFFSET PLP            ;GET STATUS FLAG BPL PLOOP      ;IF BIT 8 ZERO RTS            ;RETURN;*********************************; CONVERT ASCII TO BYTE DATA;*********************************BYTASC CMP #$3A ;IS CHAR >9 PHP            ;PUSH P AND #$0F       ;MASK HIGH BYTE PLP            ;PULL P BCC EXIT1      ;IF <=9 OK ADC #$08       ;ADD OFFSETEXIT1 RTS       ;RETURN;*********************************; INPUT CHARACTER FORM DISK;*********************************INPUT JSR CHRIN ;INPUT CHAR PHA            ;STORE LDA STATUS     ;GET STATUS BYTE BEQ JUMP       ;IF ZERO OK CMP #$40       ;END OF FILE? BNE DISKER     ;IF NOT ERRORJUMP PLA        ;GET CHAR RTS            ;RETURN;*********************************; PULL RETURN RETURN FOR ERROR;*********************************DISKER PLA      ;PULL INPUT CHAR PLA            ;PULL RETURN PLA            ; PLA            ;PULL RETURN PLA            ; JMP ERROR      ;GOTO ERROR HANDLE;*********************************; SUM BYTES FOR CHECKSUMS;*********************************SUMBYT CLC      ;CLEAR CARRY ADC USER       ;ADD BYTE OF CHECK STA USER       ;REPLACE BYTE BCC EXIT       ;IF NO CARRY OK INC USER+1     ;INC HIGH BYTEEXIT RTS        ;RETURN;*********************************; INPUT CHARACTER INTO BYTE;*********************************GETBYT LDA #$00  ;ZERO BYTE STA TEMP        ;STORE IN TEMP JSR INPUT       ;GET CHAR INPUTCHCKSP CMP #' '  ;IS IT A SPACE? BNE CREBYT      ;IF NOT CREATE JSR INPUT       ;GET CHAR INPUT CMP #' '        ;IS IT S SPACE? BNE NEXBYT      ;IF NOT GO ON CLC             ;FLAG ERROR RTS             ;RETURN;*********************************; CREATE BYTE FORM 2 ASCII CHARS;*********************************CREBYT JSR BYTASC ;GET HIGH NIBBLE ASL A            ;LEFT JUSTIFY ASL A            ; ASCII CHAR ASL A            ;  IN HIGH ASL A            ;   NIBBLE STA TEMP         ;STORE JSR INPUT        ;GET INPUTNEXBYT JSR BYTASC ;CREATE LOW NIB ORA TEMP         ;PUT IN PLACE SEC              ;FLAG OK RTS              ;RETURN;*********************************; SAVE AND PRINT LOAD ADDRESS;*********************************PRTADD LDA ZEROPG ;LOW ADDRESS STA SAV      ;SAVE HIGH BYTE START ADDRESS PHA          ;STACK IT LDA ZEROPG+1 ;GET HIGH BYTE STA SAV+1    ;SAVE LOW BYTE START ADDRESS JSR RIGHT    ;PRINT IT PLA          ;PULL LOW BYTE;RIGHT PHA     ;STACK BYTE LSR A        ;RIGHT JUSTIFY LSR A        ; BYTE IN LOW LSR A        ;  NIBBLE LSR A        ; JSR CHGASC   ;CONVERT BYTE TAX          ;STORE IN X PLA          ;PULL BYTE AND #$0F     ;MASK HIGH JSR CHGASC   ;CONVERT BYTE;*********************************; PRINT START ADDRESS;********************************* PHA          ;STACK RESULT TXA          ;GET HIGH NIBBLE  JSR CHROUT   ;PRINT IT PLA          ;GET LOW NIBBLE JMP CHROUT   ;PRINT AND RETURN;*********************************; CONVERT BYTE TO ASCII CHAR;*********************************CHGASC CLC      ;CLEAR CARRY ADC #$F6       ;ADD OFFSET BCC NOSIX      ;IF C=0 OK ADC #$06       ;ADD OFFSSETNOSIX ADC #$3A  ;ADD OFFSET RTS            ;RETURN;*********************************; INIT DISK;*********************************INIT  .TEXT 'I0';*********************************; STORAGE;*********************************USER .WORD $AAAA   ;CHECKSUM VALUEOFFSET .WORD $AAAA ;LOAD OFFSETNUMBYT .BYTE $AA   ;NUMBER BYTESRECORD .WORD $AAAA ;RECORD NUMBERCOUNT .BYTE $AA    ;COUNTERTEMP .BYTE $AA     ;TEMPOARY;*********************************; FILENAME NAME BUFFER;*********************************BUF .BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA;*********************************COUNT1 .BYTE $AA   ;COUNTER;*********************************; ERROR MESSAGES;*********************************MSG1 .BYTE $0D.TEXT 'BAD RECORD COUN',$D4MSG2 .BYTE $0D.TEXT 'BREAK',$8DMSG3 .BYTE $0D.TEXT 'END OF LOA',$C4MSG4 .BYTE $0D.TEXT 'NON-RAM LOA',$C4MSG5 .BYTE $0D.TEXT 'CHECKSUM ERRO',$D2MSG6 .BYTE $0D.TEXT 'FILE ERRO',$D2;*********************************; MESSAGES; ; FIRST TWO CHARACTERS IN TITLE; ARE DEFINED IN MAIN DEFINITION; SOURCE CODE FILE; LOLOADER.ASM OR HILOADER.ASM;;*********************************MSG7 .BYTE $0D,$0D,$0D;.BYTE 'LOLOAD.C64 V072882';.BYTE 'HILOAD.C64 V072882'.BYTE TITLE1,TITLE2.TEXT 'LOAD.C64 V072882'.BYTE $0D.TEXT '(C) 1982 BY COMMODORE BUSINESS '.TEXT 'MACHINES';.BYTE 'MACHINES',$0D,$0D,$0D;.BYTE 'HEX OFFSET (CR IF NONE) '.TEXT '?',$A0MSG8 .BYTE $0D.TEXT 'OBJECT FILE NAME ?',$A0MSG9 .BYTE $0D.TEXT 'PRG NAME',$BAMSG10 .BYTE $0D.TEXT 'OBJ NOT SAVED',$A0;*********************************; START LOAD ADDRESS;*********************************SAV   .WORD $AAAA ;ADDRESS SAVESA    .WORD $AAAA ;START ADDRESSEA    .WORD $AAAA ;END ADDRESSSAFG  .BYTE $00   ;START ADDRESS FLAGECODE .BYTE $00   ;ERROR CODE;*********************************;;*********************************.INCLUDE "savobj.asm";*********************************;;*********************************;.LIB FILERR.ASM;*********************************.END